# 设备模型(device model)


## 1 前言
>作者：wowo
>由于Linux支持世界上几乎所有的、不同功能的硬件设备（这是Linux的优点），导致Linux内核中有一半的代码是设备驱动，而且随着硬件的快速升级换代，设备驱动的代码量也在快速增长。为了降低设备多样性带来的Linux驱动开发的复杂度，以及设备热拔插处理、电源管理等，Linux内核提出了设备模型（也称作Driver Model）的概念。设备模型将硬件设备归纳、分类，然后抽象出一套标准的数据结构和接口。驱动的开发，就简化为对内核所规定的数据结构的填充和实现。

## 2 设备模型基本概念
* **总线（Bus）**：总线是处理器与一个或者多个设备之间的通道。在设备模型中，所有的设备都通过总线相连，甚至是那些内部的虚拟“平台”总线（比如Platform Bus[^1]）。在linux设备模型中，用bus_type结构体表示总下，详见内核```linux/device.h```。

*  **类（Class）**：集合了具有相似功能或属性的设备，抽象出一套可以在多个设备之间公用的数据类型和接口函数。从属于相同类的设备驱动程序，就不需要重复定义这些资源，直接从类中继承即可。[1]

* **设备（Device）**：抽象出系统中所有的硬件设备，描述它的名字、属性、从属的bus、从属的class等信息。linux系统中设备主要分为三大类，字符设备、块设备及网络设备。

* **设备驱动（Device driver）**：设备驱动是系统内核和硬件设备之间的纽带，为应用层屏蔽了硬件细节，使应用程序可以像操作普通文件一样操作硬件设备。linux用driver抽象出设备的驱动程序，它包含设备初始化、电源管理相关等接口的实现。而Linux内核中的驱动开发，基本都围绕该抽象进行（实现所规定的接口函数）

## 3 Linux 设备
Linux 系统将硬件设备抽象后分为三类：字符设备、块设备、网络设备。
### 3.1 设备分类
* **字符设备** 
    字符设备只能一个个字节读写，不能随机读取设备内存中的某一数据，读取需要按照先后顺序。字符设备驱动程序通常至少要实现 open、close、read 和 write 系统调用。字符设备可以通过文件系统节点来访问，比如：```/dev/tty1``` 等。
    字符设备是面向字节流的设备，常见的字符设备有鼠标、键盘、串口、控制台、LED 等。

* **块设备** 
    和字符设备类似，也可以通过/dev目录的文件系统节点来访问。块设备可以从设备的任意地址读取一定长度的数据。因而块设备和字符设备的区别仅仅在于内核内部管理数据的方式，也就是内核及驱动程序间的软件接口，而这些不同对用户是透明的。常见的块设备有硬盘、磁盘、SD卡、U盘等。

* **网络设备**  
    网络设备可以是一个硬件设备，如网卡；也可以是个软件设备，如网络回环接口。许多网络连接（如 tcp ）是面向流的，但网络设备是围绕数据包传输和接受设计的。网络驱动程序不需要知道各个连接的相关信息，他只要处理数据包即可。由于不是面向六的设备，将网络设备接口映射到文件系统中节点比较困难，所以 linux 内核中给网络接口分配了一个唯一的名字（如 eth0），但这个名字在文件系统中不存在节点。因而内核核网络设备驱动程序间的通信完全不同与内核核字符及块设备驱动程序间通信，在 linux 中，用户程序最终使用套接字（ socket ）来访问网络设备。

### 3.2 设备节点和设备号
#### 3.2.1 设备节点
Linux 的各种设备都以文件的形式存放在 ```/dev``` 目录下，这些名称被称为特殊文件、设备文件或者文件节点。设备驱动程序的设备文件可通过```ls -l``` 命令获得（如下图），输出的第一列中的字符 "c" 来识别（块设备由字符 "b" 标识，d 则表示是目录，l 表示是链接文件， p 表示命名管道， s 表示 Socket 文件）。
![设备文件信息](/assets/设备文件信息.png)
为了管理这些设备，系统为各个设备进行编号，每个设备号，又分为主设备号和次设备号。主设备号用来区分不同种类的设备，如 USB、tty 等，次设备号用来区分同一类型的多个设备，如 tty0、tty1。以上图 ```/dev/ttyS0``` 文件节点为例，对其中几项内容作以说明：
![设备文件说明](/assets/设备文件说明.png)
```/dev/ttyS0``` 是设备节点名称，c 表示该设备是字符设备，主设备号为 4，从设备号为 64，该设备节点对应于系统的串口 0。

#### 3.2.2 设备号
　　Linux 内核使用 **dev_t** 类型来定义设备号以确定设备的唯一性，dev_t 实际是个 unsigned int 类型，其中高 12 位表示主设备号，低 20 位表示次设备号。主设备号标识设备对应的驱动程序，告诉 Linux 内核使用哪个驱动程序驱动该设备。如果多个设备使用同一个驱动程序，则它们拥有相同的主设备号。从设备号用于确定该设备文件所指定的设备。如果一个设备驱动可以驱动一组相似的设备，此时就需要依赖于次设备号对这些外设进行区分。

内核中提供了三个宏函数用于设备号与主、次设备号之间的转换：
1)从设备号中提取 major 和 minor
```major = MAJOR(dev_t dev);//获取主设备号```　　　　　　　　　　　　　　　　　　　　　　　 
```minor = MINOR(dev_t dev);//获取从设备号```	
2)通过 major 和 minor 构建设备号
```dev_id = MKDEV(int major,int minor);//生成设备号```

### 3.3 设备号的注册与注销
注册与注销的方法请具体看各个驱动笔记

## 4 Linux 设备与驱动
![设备与设备驱动的关系](/assets/设备与设备驱动的关系.png)
驱动程序运载内核空间，用户程序只能通过内核提供的系统调用，经由 VFS 以及驱动程序才能访问和操作设备，硬件设备传递的数据也必须经过驱动、 VFS 和系统调用才能被用户程序获得。
Linux 设备驱动是具有入口和出口的一组方法集合，各方法互相独立。驱动内部结构如下图所示：
![驱动结构图](/assets/驱动结构图.png)
一个完整的驱动程序需要具备一下几部分内容：
**1）驱动入口和出口**
    驱动入口和出口代码不予应用程序直接交互，至于内核模块管理子系统有交互。在加载内核时执行入口代码，卸载时执行出口代码。此部分内容和内核版本关系较大，不同版本的内核，实现方式不同。
**2）操作设备的各种方法**
    驱动程序的各个方法不能主动执行，只能被动等待应用程序的系统调用。如应用程序执行 read() 系统调用，内核才会执行驱动 xxx_read()方法的代码。
**3）设备管理方法**
    包括设备号的分配和设备的注册等。这部分代码也与内核版本以及系统采用的设备管理框架有关，例如linux早期需要驱动开发者建立设备节点，而在 linux2.6 之后引用了 udev 管理框架,驱动程序会自动创建设备节点。

### 4.1 驱动的实现
    详见各个驱动笔记

### 4.2 驱动的编译
    详见《Linux内核模块》笔记

### 4.3 驱动的加载与卸载
    详见《Linux内核模块》笔记

## 参考文档
* 《Linux设备驱动程序（第三版）》
* [《Linux设备模型(1)_基本概念》---蜗窝科技](http://www.wowotech.net/device_model/13.html)
* 《嵌入式Linux开发教程下册》---周立功



[^1]:Platform Bus:
在计算机中有这样一类设备，它们通过各自的设备控制器，直接和CPU连接，CPU可以通过常规的寻址操作访问它们（或者说访问它们的控制器）。这种连接方式，并不属于传统意义上的总线连接。但设备模型应该具备普适性，因此linux就虚构了一条 Platform Bus ，供这些设备挂靠。